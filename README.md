# PolyProof-Circuit

This repository demonstrates the implementation of a zkSNARK circuit that carries out specific logical operations. The goal of the circuit is to validate knowledge of inputs A = 0 and B = 1, resulting in an output of 0. Additionally, this project covers the deployment of a verifier contract on-chain to confirm proofs generated by this circuit.

## Overview

This Circom-based project showcases the creation of a zkSNARK circuit that proves the knowledge of predefined logical inputs and their corresponding output. The circuit incorporates logical gates, and the produced proof is verified on-chain by a verifier contract deployed on the Polygon network (zkEVM Cardona, Sepolia, or Mumbai Testnet).

## Requirements

- [MetaMask](https://metamask.io/) extension for your browser
- [Hardhat](https://github.com/gmchad/zardkat) for contract compilation and deployment
- [Circom](https://docs.circom.io/) for writing and compiling the circuit
- Visual Studio Code or another suitable development environment

## Instructions

### Running the Project

1. You can use VS Code or GitPod to work on this project.
2. In the sidebar, click the "+" icon to create a new file.
3. Clone the Hardhat Circom repository.
4. Write the circuit code as described below.

![image](https://github.com/user-attachments/assets/b2ecc304-5c9e-4ed6-8b19-7ba18bc20612)

```
// SPDX-License-Identifier: MIT
pragma circom 2.0.0;

/* This circuit template checks if c is the result of multiplying a and b. */

template ZKSnarkCircuit () {  
   signal input A;
   signal input B;
   
   signal X;
   signal Y;
   
   signal output Q;

   component And_Gate = AND();
   component Not_Gate = NOT();
   component Or_Gate = OR();
   
   And_Gate.a <== A;
   And_Gate.b <== B;
   X <== And_Gate.out;

   Not_Gate.in <== B;
   Y <== Not_Gate.out;

   Or_Gate.a <== X;
   Or_Gate.b <== Y;
   Q <== Or_Gate.out;
}

template AND() {
    signal input a;
    signal input b;
    signal output out;

    out <== a * b;
}

template NOT() {
    signal input in;
    signal output out;

    out <== 1 + in - 2 * in;
}

template OR() {
    signal input a;
    signal input b;
    signal output out;

    out <== a + b - a * b;
}

component main = ZKSnarkCircuit();
```

### Installation
Run the following command to install dependencies:
```bash
npm i
```

### Compile
Compile the circuit using the command:
```bash
npx hardhat circom
```
This will generate an **out** folder containing intermediary circuit outputs and the **MultiplierVerifier.sol** contract.

### Proof Generation and Deployment
Use this command to generate a proof and deploy the verifier contract:
```bash
npx hardhat run scripts/deploy.ts --network zkEVM
```
This script handles the following tasks:
1. Deploys the `MultiplierVerifier.sol` contract.
2. Generates a proof using the circuit intermediaries through `generateProof()`.
3. Converts proof data into calldata with `generateCallData()`.
4. Calls the `verifyProof()` function on the deployed verifier contract with the calldata.

In just two commands, you can compile the zkSNARK circuit, generate a proof, deploy the verifier, and verify the proof on-chain ðŸŽ‰

## Project Setup

### Directory Layout
**circuits**
```
â”œâ”€â”€ multiplier
â”‚   â”œâ”€â”€ circuit.circom
â”‚   â”œâ”€â”€ input.json
â”‚   â””â”€â”€ out
â”‚       â”œâ”€â”€ circuit.wasm
â”‚       â”œâ”€â”€ multiplier.r1cs
â”‚       â”œâ”€â”€ multiplier.vkey
â”‚       â””â”€â”€ multiplier.zkey
â”œâ”€â”€ new-circuit
â””â”€â”€ powersOfTau28_hez_final_12.ptau
```
Each circuit resides in its own folder. Inside each folder, the circom file and input are placed. Compiled outputs, keys, and proofs are stored in the **out** folder. The Powers of Tau file comes from the Polygon Hermez ceremony, allowing us to skip generating a new one.

**contracts**
```
contracts
â””â”€â”€ MultiplierVerifier.sol
```
The autogenerated verifier contracts are named after the circuit (e.g., **MultiplierVerifier**).

### Configuration in hardhat.config.ts
```ts
circom: {
    inputBasePath: "./circuits",
    ptau: "powersOfTau28_hez_final_12.ptau",
    circuits: JSON.parse(JSON.stringify(circuits))
}
```

### circuits.config.json
```
[
  {
    "name": "multiplier",
    "protocol": "groth16",
    "circuit": "multiplier/circuit.circom",
    "input": "multiplier/input.json",
    "wasm": "multiplier/out/circuit.wasm",
    "zkey": "multiplier/out/multiplier.zkey",
    "vkey": "multiplier/out/multiplier.vkey",
    "r1cs": "multiplier/out/multiplier.r1cs",
    "beacon": "0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"
  }
]
```
To add a new circuit, you can use the `newcircuit` task:
```bash
npx hardhat newcircuit --name newcircuit
```

## Adding Polygon zkEVM Cardona Testnet to MetaMask

1. Open MetaMask, click the network dropdown, and choose "Add Network."
2. Use the following information:
    - **Network Name:** Polygon zkEVM Cardona Testnet
    - **RPC URL:** https://polygon-zkevm-cardona.blockpi.network/v1/rpc/public
    - **Chain ID:** 2442
    - **Symbol:** ETH
3. Save the configuration and switch to the new network.

## Verifying the Contract

1. Visit [PolygonScan](https://cardona-zkevm.polygonscan.com/).
2. Search for your contract address and complete the verification process.

## Author
Parth Tiwari

